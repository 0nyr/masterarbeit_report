\section{Background}\label{sec:background}

% Introduce the related state-of-the-art and background information in order to understand the method developed in the thesis. 

The evolving landscape of cybersecurity necessitates robust techniques for safeguarding digital communications. OpenSSH, a pivotal element in this landscape, is a popular implementation of the Secure Shell (\acrshort{ssh}) protocol, which enables secure communication between two networked devices. The protocol is widely used in the industry, particularly in the context of remote access to servers. Using digital forensic techniques, it is possible to extract the SSH keys from memory dumps, which can then be used to decode encrypted communications thus allowing the monitoring of controlled systems. At the crux of this Masterarbeit is the development of machine learning algorithms to predict SSH keys within these heap dumps, focusing on using graph-like-structures and vectorization for custom embeddings. With an interdisciplinary approach that fuses traditional feature engineering with graph-based methods as well as memory modelization for inductive reasoning and learning inspired by recent developments in \acrfull{kg}s, this research not only leverages existing machine learning paradigms but also explores new avenues, such as \acrfull{gcn}.

The objective of this background section is multifaceted. Since the project has seen two distinct phases, one more classical \acrfull{ml} approach, and a second one centered aroung graph-based advanced learning methods, the background section is divided into several subsections that introduce the reader to the different concepts and techniques used in the project. First, it aims to offer an overview of SSH protocols, particularly focusing on OpenSSH key implementations \autoref{sec:background:ssh}. Second, it delineates the dataset and prior work on key extraction techniques including SmartKey \autoref{sec:background:kex}. Third, it delves into the technical aspects of graphs modelization \autoref{sec:background:graph}, followed by feature engineering and embeddings both traditional and graph-based \autoref{sec:background:processing}. Finally, it addresses the machine learning models employed in the research, emphasizing their suitability for maximizing recall in key prediction \autoref{sec:background:ml}. By fusing these distinct but interrelated areas, this section lays the foundation for the research methodologies and hypotheses tested in this study.

\subsection{SSH and OpenSSH Implementation}\label{sec:background:ssh}

    \subsubsection{Basics of the Secure Shell Protocol (SSH)}
    
    The Secure Shell Protocol, commonly known as \acrshort{ssh}, is designed to facilitate secure remote login and other secure network services over insecure networks. \acrshort{ssh} has been design since its inception with security in mind, as a successor of the Telnet protocol, which is not secure, and other \say{unsecured remote shell protocols such as rlogin, rsh and rexec} \cite{SSHkex22}. As stated by the authors of the \citetitle{SSHReport18}, \say{The founder of SSH, Tatu Yl√∂nen, designed the first version of the SSH protocol after a password-sniffing attack at his university network. Tatu released his implementation as freeware in July 1995, and the tool quickly gained in popularity. Towards the end of 1995, the SSH user base had grown to 20,000 users in fifty countries. By 2000, there were an estimated 2,000,000 users of the protocol. Today, more than 95\% of the servers used to power the Internet have SSH installed in them. The SSH protocol is truly one of the cornerstones of a safe Internet.} \cite{SSHReport18}.

    \acrshort{ssh} is defined in \citetitle{RFC4251} \cite{RFC4251}. It is divided into three major components:

    \begin{itemize}
        \item \textbf{Transport Layer Protocol:} This provides server authentication, confidentiality, and integrity. It can also optionally provide compression. Typically, the transport layer runs over a TCP/IP connection but can also be used on top of any other reliable data stream.
        \item \textbf{User Authentication Protocol:} Running over the transport layer, this protocol authenticates the client-side user to the server. Multiple methods of authentication such as password and public key are supported.
        \item \textbf{Connection Protocol:} This multiplexes the encrypted tunnel established by the preceding layers into several logical channels. Channels can be used for various purposes, such as setting up secure interactive shell sessions or tunneling arbitrary TCP/IP ports.
    \end{itemize}

    \say{The client sends a service request once a secure transport layer connection has been established. A second service request is sent
    after user authentication is complete. This allows new protocols to be defined and coexist with the protocols listed above} \cite{RFC4251}.

    For the scope of this Masterarbeit, understanding SSH's key exchange and encryption mechanism is important. As Summarized in SSHKex \cite{SSHkex22}, the SSH key exchange procedure results in a derived master key \textit{K} and a hash value \textit{h}. These are critical for client-server communication encryption and session identification.

    During the key exchange, multiple session keys are computed for different purposes:

    \begin{itemize}
        \item \textbf{Initialization Vectors:} Key A and Key B are used for initialization vectors from the client to the server and vice versa.
        \item \textbf{Encryption Keys:} Key C and Key D serve as encryption keys for client-to-server and server-to-client communications, respectively.
        \item \textbf{Integrity Keys:} Key E and Key F are used to maintain the integrity of the data transmitted between the client and server.
    \end{itemize}

    These keys are computed using hash functions that take the master key \textit{K} and a hash value \textit{h}, a unique letter (A, B, C, D, E, or F), and the session ID as inputs. This is summarized in \citetitle{OpenSSHUnderHood07}:
    \say{
        The equations used for deriving the above vectors and keys are taken from RFC 4253 \cite{RFC4253}. In the following, the $||$ symbol stands for concatenation, K is encoded as mpint, $"A"$ as byte and $session_id$ as raw data. Any letter, such as the $"A"$ (in quotation marks) means the single character A, or ASCII 65.
        \begin{itemize}
            \item Initial IV client to server: $HASH(K || H || "A" || session_id)$.
            \item Initial IV server to client: $HASH(K || H || "B" || session_id)$.
            \item Encryption key client to server: $HASH(K || H || "C" || session_id)$.
            \item Encryption key server to client: $HASH(K || H || "D" || session_id)$.
            \item Integrity key client to server: $HASH(K || H || "E" || session_id)$.
            \item Integrity key server to client: $HASH(K || H || "F" || session_id)$.
        \end{itemize}
    } \cite{OpenSSHUnderHood07}. Details about the hash function are given in the next section.
    
    The most interesting keys are the encryption keys, as they are used to encrypt the communication between the client and the server. The other keys are used for integrity checks and initialization vectors. Decrypting encrypted SSH communication necessitates either to retreive these session keys and variables so as to recompute the keys, or to retreive those keys directly, which is the focus of this Masterarbeit. 

    \subsubsection{OpenSSH Implementation}
    OpenSSH (OpenBSD Secure Shell) is an open-source implementation written in C of the SSH protocol suite, and it is the most widely used SSH implementation \cite{OpenSSHUnderHood07}. It is the default SSH implementation on most Linux distributions, and it is also available for Windows. OpenSSH is used for a wide range of purposes, including remote command-line login and remote command execution. It is also used for port forwarding, tunneling, and transferring files via SCP and SFTP either manually or via automated processes, such as backup systems, configuration management tools, and automated software deployment tools. 

    OpenSSH is composed of several tools and daemons, including client and server components \cite{PortableOpenSSHGitHub}:
    \begin{itemize}
        \item \textbf{ssh:} The basic client program that allows to log into and execute commands on a remote machine.
        \item \textbf{scp:} A program for securely copying files between machines.
        \item \textbf{sftp:} An interactive file transfer program that uses SSH to secure the connection.
        \item \textbf{sshd:} This is the SSH daemon that runs on the server. This is used for connecting to a remote machine when using the SSH client from another system.
        \item \textbf{ssh-agent:} The program that holds private keys in memory, so one doesn't have to enter ones passphrase every time.
        \item \textbf{ssh-add:} A program for adding RSA or DSA identities to the authentication agent.
        \item \textbf{ssh-keygen:} A utility for creating and managing SSH keys.
        \item \textbf{ssh-keyscan:} A utility for gathering public SSH host keys from a number of hosts.
        \item \textbf{ssh-keychk:} A utility for checking the validity of SSH keys.
        \item Several other tools to support the SSH protocol and the OpenSSH implementation.
    \end{itemize}

    OpenSSH employs a variety of hash functions and algorithms to secure data, most commonly using SHA1. However, SHA1 is increasingly seen as weak due to its vulnerability to collision attacks \cite{OpenSSHUnderHood07}. In light of this, the contemporary standard leans towards SHA512. The hash functions are used alongside cipher algorithms like \say{Advance Encryption Standard (AES) Cipher Block Chaining (CBC), AES Counter (AES-CTR), and ChaCha20} \cite{SmartKex22}. The Message Authentication Code (MAC) typically uses either MD5 or SHA1 hash algorithms in combination with a secret key. Since cybersecurity and cryptography are constantly evolving, so do \acrshort{ssh} and OpenSSH. Depending on the version \cite{OpenSSHUnderHood07}, the available hash options include:
    
    \begin{itemize}
        \item \textbf{ssh-dss:} \textit{(disabled at run-time since OpenSSH 7.0 released in 2015)} SSH-1 version using Digital Signature Algorithm (DSA) from the Digital Signature Standard (DSS). Originally popular but phased out due to vulnerabilities to collision attacks for DSA Key in a 1024-bit modulus. As stated by \citetitle{RFC9142}: \say{These attacks are still computationally very difficult to perform, but it is desirable that any key exchange using SHA-1 be phased out as soon as possible} \cite{RFC9142} \cite{OpenSSHReleaseNotes7-0}.
        
        \item \textbf{ssh-rsa:} \textit{(disabled at run-time since OpenSSH 8.8 released in 2021)} It refers to the use of RSA (Rivest-Shamir-Adleman) encryption algorithm. In the context of SSH-1, this version had to be replaced due to the related to key size issue similar to DSS: \say{RSA 1024-bit keys have approximately 80 bits of security strength}... \say{which may not be sufficient for most users.} \cite{RFC9142} \cite{OpenSSHReleaseNotes8-8}.
        
        \item \textbf{ecdsa-sha2-nistp256:} \textit{(since OpenSSH 5.7 released in 2011)} Uses the SHA-2 family for hashing and the NIST P-256 curve. It is considered secure and efficient, with an \acrfull{ess} of 128 bits \cite{RFC9142} \cite{OpenSSHReleaseNotes5-7}.
        
        \item \textbf{ecdsa-sha2-nistp384:} \textit{(since OpenSSH 5.7)} Utilizes the SHA-2 family and the larger NIST P-384 curve for additional security at the cost of performance. It has an \acrshort{ess} of 192 bits \cite{RFC9142} \cite{OpenSSHReleaseNotes5-7}.
        
        \item \textbf{ecdsa-sha2-nistp521:} \textit{(since OpenSSH 5.7)} Employs SHA-2 and the even larger NIST P-521 curve for maximal security with an \acrshort{ess} of 256 bits \cite{RFC9142}. It is less commonly used due to performance considerations \cite{OpenSSHReleaseNotes5-7}. 
        
        \item \textbf{ssh-ed25519:} \textit{(since OpenSSH 6.5 released in 2014)} Known for high security and performance efficiency; employs the Ed25519 elliptic curve with an \acrshort{ess} of 128 bits \cite{RFC9142} which is similar to $ecdsa-sha2-nistp256$, and has been more prevalent following the 2013 suspicions of NSA backdoors in NIST curves \cite{Adamantiadis2013} following the Snowden revelations \cite{NSAFoilSafeguards2013} \cite{GuardianEncryption2013} \cite{OpenSSHReleaseNotes6-5}.
        
        \item \textbf{rsa-sha2-256:} \textit{(since OpenSSH 7.2 released in 2016)} An upgrade from ssh-rsa, using SHA-256 (with \acrshort{ess} of 128 bits) for hashing to improve security without major performance hits \cite{OpenSSHReleaseNotes7-2}.
         
        \item \textbf{rsa-sha2-512:} \textit{(since OpenSSH 7.2)} Similar to $rsa-sha2-256$ but employs SHA-512 for even stronger security, albeit with some performance cost \cite{OpenSSHReleaseNotes7-2}.
        
        \item \textbf{ecdsa-sk:} \textit{(since OpenSSH 8.2 released in 2020)} Security Key-enabled, uses NIST curves and is geared towards modern hardware-based authentication \cite{OpenSSHReleaseNotes8-2}.
        
        \item \textbf{ed25519-sk:} \textit{(since OpenSSH 8.2)} Similar to ssh-ed25519 but integrates hardware-based Security Keys for an additional layer of security \cite{OpenSSHReleaseNotes8-2}.
        
        \item \textbf{NTRU Prime-x25519:} \textit{(since OpenSSH 9.0)} A new, highly secure algorithm focused on post-quantum cryptography, providing future-proof security \cite{NTRUPostQuantum17} \cite{OpenSSHReleaseNotes9-0}.
    \end{itemize}
    
    These hashes have fixed lengths such that key lengths range between 12 and 64 bytes \cite{SmartKex22}. Since high-quality random number generation is crucial to ensure that thoses keys are secure and difficult to predict, it can thus be assumed that thoses key have a high entropy \cite{McLaren2019}. This is a crucial assumption as it is the basis for the use of both brute force and machine learning algorithms to predict the presence and location of SSH keys in memory dumps.

    The keys generated by these hash functions are pseudo-random numbers stored in the system's RAM. Following the Kerckhoffs' principle: that \say{a cryptosystem should be secure, even if everything about the system, except the key, is public knowledge}, the code for the OpenSSH implementation is open-source and available on GitHub \cite{PortableOpenSSHGitHub}. This allows for the analysis of the code and the identification of the memory structures where the keys are stored.

    \subsubsection{The state of SSH security}
    Since its origins, SSH has been developed with cybersecurity in mind, and is generally considered a secure method for remote login and other secure network services over an insecure network. However, as with any technology, it can be exploited if not configured or managed correctly. The protocol is used by system administrators to manage remote systems, and it is also used by automated processes to transfer data and perform other tasks. This makes SSH a valuable target for attackers. In fact, SSH has been a popular target for cyber-attacks. Due to being so prevalent, it is often used by threat actors either as a vector for initial access, as a means to move laterally across a network or as a covered exit for exfiltration of sensitive data \cite{APTTactics19}. The encrypted nature of its communications makes it an attractive option for attackers, as it can be difficult to detect malicious activity.
    
    Here are some cases where SSH can involved in cyber-attacks, although it's important to note that SSH itself is not inherently insecure:
    \begin{itemize}
        \item \textbf{SSH Brute-Force Attacks:} One of the most common types of attacks involving SSH is a brute-force attack, where an attacker tries to gain access by repeatedly attempting to login with different username-password combinations. These attacks are not sophisticated but can be effective if strong authentication measures are not in place. For instance, the botnet \textit{Chabulo} was used to launch a large-scale brute-force attack \say{through compromised SSH servers and IoT devices} in 2018 \cite{SSHReport18}. 
        \item \textbf{SSH Key Theft:} In some advanced attacks, threat actors have stolen SSH keys to move laterally across a network after initial entry. This allows them to authenticate as a legitimate user and can make detection much more challenging. It can \say{ occurs when users have their SSH password or unencrypted keys stolen through a variety of methods (sniffed via a key-logging console program, shoulder-surfed via bad security awareness, poor key management practices, etc.).} \cite{SSHIdentityTheft05}.
        \item \textbf{Man-in-the-Middle Attacks:} Although SSH is designed to be secure, it can be susceptible to man-in-the-middle attacks if proper verification of SSH keys is not done during the initial connection setup \cite{OpenSSHUnderHood07}.
        \item \textbf{Misconfiguration:} As with any technology, misconfiguration can lead to security issues. For example, leaving default passwords, using weak encryption algorithms, or enabling root login can all make an SSH-enabled system vulnerable \cite{SSHBotnetInfect21}.
    \end{itemize}

    \subsubsection{SSH vulnerabilities and use in cyber-attacks}
    In cybersecurity, it is generally considered that any system that is connected to the Internet will be attacked at some point. Similarly, it is a common saying that no system is 100\% secure. This is true for SSH as well. Although it is a secure protocol, it can be exploited if not configured or managed correctly. 
    
    Some vulnerabilities have also been discovered in the protocol itself, although these are rare.
    \begin{itemize}
        \item \textbf{SSH-1 Vulnerabilities:} A series of vulnerabilities in the first implementation of SSH were discovered from 1998 to 2001, with its subsequent fixes leading to unauthorized content insertion and arbitrary code execution. SSH-1 had many design flows and is now considered obsolete. \cite{CoreSecurity23}, \cite{SSH1Vulnerability01}. 
        \item \textbf{CBC Plaintext Recovery:} A theoretical vulnerability discovered in 2008 affecting all versions of SSH, allowing the recovery of up to 32 bits of plaintext from CBC-encrypted ciphertext \cite{USCERT2011}.
        \item \textbf{Suspected Decryption by NSA:} Leaked information in 2014 suggested that the NSA might be able to decrypt some SSH traffic, although the protocol itself was not confirmed to be compromised \cite{Spiegel14}.
    \end{itemize}
    
    SSH has been used in many high-profile cyber-attacks and malwares, including the following:
    \begin{itemize}
        \item \textbf{Operation Windigo:} This was a large-scale campaign that infected over 25,000 UNIX servers. SSH was one of the vectors used for maintaining control over compromised servers. A report by ESET mentions that the  OpenSSH backdoor Linux/Ebury was first discovered in 2011 as a component of the aforementioned operation. \say{This operation has been ongoing since at least 2011 and has affected high profile servers and companies, including cPanel - the company behind the famous web hosting control panel - and Linux Foundation's kernel.org - the main repository of source code for the Linux kernel} \cite{ESETWindigo14}. 
        \item \textbf{Linux/Hydra:} Initially unleashed in 2008, this malware is a fast login cracker that targets a range of popular protocols including SSH. Hence, SSH is one of its primary vectors to gain initial access to Internet of Things (IoT) devices. Once a device is infected by Linux/Hydra, it joins an IRC channel and initiates a SYN Flood attack \cite{ClassificationMalware21}.
        \item \textbf{Psyb0t:} Discovered in early 2009, Psyb0t is an IRC-controlled malware specifically designed to target devices with MIPS architecture, such as routers and modems. Notably, it was responsible for orchestrating a DDoS attack against the DroneBL service, infecting up to 100,000 devices for this purpose. The malware is equipped to conduct UDP and ICMP flood attacks and employs a brute-force attack mechanism against Telnet and SSH ports. Remarkably, it uses a pre-configured list of 6,000 usernames and 13,000 passwords to perform these attacks \cite{ClassificationMalware21}.
        \item \textbf{Chuck Noris:} Similar to Psyb0t in its objectives and methods, Chuck Noris targets routers and DSL modems, focusing on SoHo (small office/home office) devices. However, unlike Psyb0t, which uses ICMP flood attacks, Chuck Noris deploys ACK flood attacks. The malware carries out brute-force attacks on Telnet and SSH open ports, drawing parallels to the tactics employed by Psyb0t but with the specific variation in flooding techniques \cite{ClassificationMalware21}.
    \end{itemize}

    It's worth noting that in many of these cases, SSH was not the initial attack vector but was used at some stage in the attack lifecycle. Properly configured and managed SSH is still considered a secure and robust protocol for remote access and data transfer. In all those situations, a tool monitoring the SSH traffic could have detected the malicious activities and prevented the attack.

    \subsubsection{The Imperative of SSH Honeypots in Cybersecurity Monitoring}
    SH (Secure Shell) has become an indispensable protocol for secure communication but can also conceil malicous agents. This reality underscores the urgency for robust monitoring mechanisms capable of identifying suspicious activities in real-time. Among various countermeasures, SSH honeypots have emerged as a particularly effective tool for monitoring and gathering intelligence on potential threats. 

    An SSH honeypot is a decoy server or service that mimics legitimate SSH services. The primary aim is to attract cybercriminals and study their tactics, thereby offering an active form of surveillance and data collection. Unlike traditional intrusion detection systems, honeypots do not merely identify an attack; they engage the attacker in a controlled environment, enabling detailed observation and logging of the intruder's actions. This allows for the collection of valuable information, such as the attacker's IP address, the tools used, and the techniques employed. This data can then be used to enhance security measures and develop more robust countermeasures \cite{ClassificationMalware21}. 

    SSH honeypots serve as an invaluable asset in the cybersecurity arsenal, providing not just a reactive but a proactive measure against evolving cyber threats. They can collect actionable intelligence on new hacking methods, malware, and exploitation scripts. This information can be crucial for proactively securing actual production environments. The data collected can also be used to trace back to the origin of the attack, facilitating legal pursuits against the perpetrators. By diverting attackers to decoy servers, honeypots also protect real assets from being targeted, saving both computational resources and administrative effort needed for post-incident recovery.

    Popular SSH honeypots include Kippo, Cowrie, and HoneySSH.  Cowrie is a fork of Kippo, with additional features such as logging of attacker's keystrokes and file transfer. 

    \begin{itemize}
        \item \textbf{Kippo:} Kippo is a medium-interaction honeypot that logs the attacker's shell interaction. It specializes in capturing brute force and Telnet-based attacks \cite{ClassificationMalware21}.
        
        \item \textbf{Cowrie:} Serving as Kippo's successor, Cowrie emulates various protocols including SSH, SFTP, and SCP. It logs events in JSON format, making it particularly useful for detecting brute force and Telnet-based attacks, as well as spoofing attacks \cite{ClassificationMalware21}.
        
        \item \textbf{IoTPOT:} This IoT-focused honeypot supports multiple CPU architectures and can detect a variety of attacks including brute force, DoS, and sniffing attacks on Telnet, SSH, and HTTP ports \cite{ClassificationMalware21}.
        
        \item \textbf{HoneySSH:} HoneySSH is a low-interaction honeypot that emulates an SSH server and logs the attacker's IP address, username, and password \cite{honeyssh17}.
        
        \item \textbf{Sarracenia (SSHKex):} Introduced in 2018, Sarracenia is a high-interaction SSH honeypot that has been enhanced by SSHKex. Instead of \say{requiring the VM to be paused for every incoming or outgoing packet, which degrades the server performance} \cite{SSHkex22}, SSHKex allows for the extraction of derived SSH session keys. This reduces the performance degradation significantly, as the VM is paused less frequently \cite{SSHkex22} \cite{SarraceniaSSHHoneypot18}.
    \end{itemize}

    These honeypots are useful tools for gathering intelligence on potential threats. However, they are not without their limitations. For instance, they are not able to mimic a real system, such that attackers might be able to detect them  \citetitle{SSHHoneypotEffectiveness23}. Hence, the need for more advanced SSH honeypots that can leverage data forensic and machine learning techniques so as to be able to use directly a real server as a honeypot, without the need to emulate a system. The current master's thesis is aligned with this ongoing research, further enhancing the state of SSH honeypots.

\subsection{Prior work on key extraction}\label{sec:background:kex}

    \subsubsection{SSHKex}\label{sec:background:kex:sshkex}
    
    SSHKex is a research project that aims to address the challenges of analyzing encrypted SSH traffic by leveraging \acrfull{vmi} techniques. Developed by \citeauthor{SSHkex22}, the project focuses on extracting SSH keys and decrypting SSH network traffic in a stealthy, non-intrusive manner while maintaining evidence integrity \cite{SSHkex22}. This paper is itself a continuation of the work presented in \citetitle{SarraceniaSSHHoneypot18} \cite{SarraceniaSSHHoneypot18}, which introduced Sarracenia, a high-interaction SSH honeypot. It is also related to a range of other research projects and papers \cite[section 5.6 and 6]{SSHkex22}.
    
    The SSHKex approach combines standard network traffic capturing methods with dynamic SSH session key extraction. It assumes that the SSH implementation running on the server is known, which is crucial for the key extraction process. The project employs VMI tools like LibVMI and Volatility to gain a complete and untainted view of all guest VM's state information. This allows to efficiently locate SSH session keys in the main memory of a Linux machine. 

    Here is a summary of the SSHKex methodology for key extraction:
    \begin{enumerate}
        \item \textbf{Data Structure Information:} The method leverages detailed knowledge about the data structures used to store the keys. Specific debugging symbols corresponding to the SSH implementation version on the target system provide essential offset values to facilitate the extraction of key material. The structures of interest include \texttt{struct ssh}, \texttt{struct session\_state}, \texttt{struct newkeys}, and \texttt{struct sshenc}. These structures store a range of information such as IP addresses, ports, session states, and encryption keys.

        \item \textbf{Tracing OpenSSH Functions:} Function tracing is employed to identify the precise locations of data structures and to extract keys at the right time. The focus is on two key functions: \texttt{kex\_derive\_keys} (which initiates key generation) and \texttt{do\_authentication2} (which kicks off user authentication).

        \item \textbf{Breakpoints Injection:} Software breakpoints are intentionally placed in the program execution to facilitate debugging. SSHKex utilizes Virtual Machine Introspection (VMI) to inject these breakpoints at the initial points of the two aforementioned key functions.

        \item \textbf{Key Extraction:} Upon calling the \textit{kex\_derive\_keys} function, SSHKex initially stores the address of the \textit{ssh struct}. The actual keys are extracted from memory when the \textit{do\_authentication2} function is subsequently called, adhering to the known structures. 

        \item \textbf{Key Indexing:} OpenSSH stores client-to-server and server-to-client keys in distinct indices of the \texttt{newkeys} structure. SSHKex extracts keys based on these specific indices.

        \item \textbf{Handling Multiple Connections:} To manage multiple SSH connections, OpenSSH spawns child processes. SSHKex extends its key extraction strategy to each child process by identifying them through their unique process IDs.
    \end{enumerate}
    
    One of the key strengths of SSHKex is its focus on stealthiness, preservation, and evidence integrity. The approach aims to be as unobtrusive as possible, avoiding any modifications to the system under investigation. This is particularly important in forensic contexts, where the integrity of the evidence is crucial \cite{SSHkex22}.

    \subsubsection{SmartKex}

    SmartKex is a direct followup project that focuses on the extraction of SSH keys from heap memory dumps. Its primary objective is to automate the process of SSH key extraction from heap memory dumps. The project introduces a machine learning-assisted methodology that significantly improves the efficiency and accuracy of key extraction compared to traditional brute-force methods. This method is also significantly more straightforward to implement compared to the previous SSHKex approach, which requires detailed knowledge of the SSH implementation and the ability to inject breakpoints into the program execution.

    SmartKex discusses two distinct methods for SSH key extraction:
    \begin{itemize}
        \item \textbf{Brute-Force Baseline Method:} This is a traditional approach that scans through the heap memory to identify potential keys based on known patterns.
        \item \textbf{Machine Learning-Assisted Method:} This  approach uses a Random Forest algorithm trained on a highly imbalanced dataset using \acrshort{smote} balancing. The machine learning model is designed to identify SSH keys with high precision and recall rates, but is not exact as compared to the brute-force method since it is based on a probabilistic model.
    \end{itemize}

        \subsubsubsection{Baseline brute-force method}

        Here is a summary of SmartKex's brute-force method for SSH key extraction from heap dumps \cite{SmartKex22}:
        \begin{enumerate}
            % complete the following with information from Christopher
            \item \textbf{Heap Dump Generation:} Heap dump binary files of OpenSSH server process have been generated and serves as the input for the key extraction process. 
            
            \item \textbf{Data Reduction:} To minimize the heap size, the method removes memory pages that are irrelevant (empty) based on Hamming distance.
            
            \item \textbf{Brute-force key search:} Starting from the first byte, a key length of 128 bytes is taken from the heap dump as the potential key. The algorithm iterates over the entire heap, continuously updating the potential key until the heap's end is reached.
            
            \item \textbf{Decryption Attempt:} For every potential key, an attempt is made to decrypt network packets. If decryption fails, the process is repeated with a new potential key.
        \end{enumerate}
        
        Although the brute-force approach is exact, it is computationally expensive. It performs poorly especially when keys are located at the end of the heap dump \cite[section 6.2]{SmartKex22}.

        \subsubsubsection{SmartKex machine-learning method}

        The real innovation of SmartKex is its machine learning-assisted methodology for SSH key extraction. At the cost fo exactness, this approach is significantly faster than the brute-force method and has a high degree of accuracy in identifying encryption keys. It also allows for the heap size to be reduced to less than 2\% of its original size, further optimizing the extraction process.

        Here is a summary of SmartKex's machine learning-assisted method for SSH key extraction from heap dumps \cite{SmartKex22}:

        \begin{enumerate}
            \item \textbf{Heap Dump inputs:} Similarly to the brute-force method, heap dump binary files of OpenSSH also serve as inputs for the key extraction process.
            \item \textbf{Preprocessing:} The raw heap dump is resized into an $N \times 8$ matrix. High entropy parts of the heap dump, which are likely to be encryption keys, are identified using the logical AND operation on the vertical and horizontal differences of adjacent bytes. This creates an array that flags potential key locations.
            \item \textbf{Training:} A Random Forest algorithm is trained on 128-byte slices of the preprocessed heap. The dataset is imbalanced, with the slices that contain keys being rare. A stacked classifier approach is used, comprising a high precision classifier and a high recall classifier.
            \item \textbf{Key Identification:} The machine learning model is used to predict which 128-byte slices of the heap dump are likely to contain encryption keys. These slices are then subjected to a brute-force method to actually extract the keys.
        \end{enumerate}

    SmartKex is significantly faster than the brute-force method alone and has a high degree of accuracy in identifying encryption keys. It also allows for the heap size to be reduced to less than 2\% of its original size, further optimizing the extraction process.

    SmartKex has broad applications in the field of cybersecurity, particularly in memory forensics. Its machine learning-assisted methodology can be adapted for other types of sensitive data extraction, making it a versatile tool for researchers and practitioners alike. The project is open-source, with the code available on GitHub \footnote{\url{https://github.com/smartvmi/Smart-and-Naive-SSH-Key-Extraction}}. The dataset is also publicly available on Zenodo \footnote{\url{https://zenodo.org/record/6537904}}.

    \subsubsection{OpenSSH memory dumps dataset}
    SmartKex has also contributed to the research community by generating a comprehensive dataset of OpenSSH heap memory dumps. The dataset is categorized based on various SSH scenarios like immediate exit, port-forward, secure copy, and shared connection. It is further organized by software version and key lengths, stored in both JSON and RAW formats.
    Open Source Contributions

    The OpenSSH memory dumps dataset is a crucial resource for researchers focusing on cybersecurity, particularly in the realm of SSH key extraction and memory forensics. Originating from the work presented in the paper "SmartKex: Machine Learning Assisted SSH Keys Extraction From The Heap Dump," this dataset provides a comprehensive collection of heap memory dumps from OpenSSH sessions.

    Dataset Composition

    The dataset is organized into two top-level directories: training and validation. These directories are further divided based on the SSH scenario, such as immediate exit, port-forward, secure copy, and shared connection. Each of these subdirectories is then categorized by the software version that generated the memory dump. Within these, the heaps are organized based on their key lengths, providing a multi-layered structure that aids in specific research queries.
    Data Formats

    Two primary file formats are used to store the data: JSON and RAW. The JSON files contain meta-information like the encryption method, virtual memory address of the key, and the key's value in hexadecimal representation. The RAW files, on the other hand, contain the actual heap dump of the OpenSSH process.
    Methodological Implications

    The dataset is not just limited to SSH key extraction; it also serves as a resource for identifying essential data structures that hold sensitive information. This makes it a versatile tool for various research applications, including but not limited to machine learning models for key extraction and malware detection.
    Open Source and Accessibility

    Both the dataset and the tools used for its generation are open-sourced. The dataset is available in a Zenodo repository, and the code can be accessed from a public GitHub repository. This ensures that the research community can easily access, modify, and contribute to this valuable resource.

\subsection{Graph-based memory modelization}\label{sec:background:graph}

    \subsubsection{Defining memory concepts and modelization}

    \subsubsection{Graphs and Knowledge Graphs}

\subsection{Data processing for Machine Learning}\label{sec:background:processing}
    \subsubsection{Feature engineering}

    \subsubsection{Graph-based embeddings}

    \subsubsection{Dataset splitting and sampling}

\subsection{Machine Learning and Deep Learning}\label{sec:background:ml}
    \subsubsection{Machine Learning}

    

    \subsubsection{Machine Learning models}

    \subsubsection{Deep Learning}

    \subsubsection{GCN}