"""
This script is used to detect all the data structures in the code.
To do so, we rely on the fact that the heap dump byte file contains
the chunks of memory generated by "GLibC-2.28"'s malloc function.

The documentation of the malloc function is available here:
https://sourceware.org/glibc/wiki/MallocInternals

The implementation code of the malloc function is available here:
https://elixir.bootlin.com/glibc/glibc-2.28/source/malloc/malloc.c

The following is a snippet of the documentation of the malloc function,
directly from the source code of the malloc function:

```c
    An allocated chunk looks like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Where "chunk" is the front of the chunk for the purpose of most of
    the malloc code, but "mem" is the pointer that is returned to the
    user.  "Nextchunk" is the beginning of the next contiguous chunk.

    Chunks always begin on even word boundaries, so the mem portion
    (which is returned to the user) is also on an even word boundary, and
    thus at least double-word aligned.

    Free chunks are stored in circular doubly-linked lists, and look like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`m-header:' |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

The flags A, M and P are used, according to the documentation, as follows:

A (0x04):   Allocated Arena - the main arena uses the application's heap.
            Other arenas use mmap'd heaps. To map a chunk to a heap, you need
            to know which case applies. If this bit is 0, the chunk comes from
            the main arena and the main heap. If this bit is 1, the chunk
            comes from mmap'd memory and the location of the heap can be
            computed from the chunk's address.

M (0x02):   MMap'd chunk - this chunk was allocated with a single call to mmap
            and is not part of a heap at all.

P (0x01):   Previous chunk is in use - if set, the previous chunk is still
            being used by the application, and thus the prev_size field is
            invalid. Note - some chunks, such as those in fastbins (see below)
            will have this bit set despite being free'd by the application.
            This bit really means that the previous chunk should not be
            considered a candidate for coalescing - it's "in use" by either
            the application or some other optimization layered atop malloc's
            original code :-)

The documentation also states that:
Note that, since chunks are adjacent to each other in memory, if you know the
address of the first chunk (lowest address) in a heap, you can iterate through
all the chunks in the heap by using the size information, but only by
increasing address, although it may be difficult to detect when you've hit the
last chunk in the heap.

Remarks:
    + Note that the bytes are little-endian in the heap dump file.
    + Within the malloc library, a "chunk pointer" or mchunkptr does not
    point to the beginning of the chunk, but to the last word in the
    previous chunk - i.e. the first field in mchunkptr is not valid
    unless you know the previous chunk is free.
"""

import numpy as np

from utils.file_loading import get_all_nested_files
from utils.heap_dump import convert_block_index_to_address, convert_int_address_to_block_index, get_blocks_from_heap_dump, get_heap_size_in_bytes, is_address_in_heap_dump, is_valid_pointer
from utils.json_annotation import get_heap_start_addr, get_json_annotations
from utils.mem_utils import block_bytes_to_addr, hex_str_to_addr, int_to_little_endian_hex_string, is_8_bytes_aligned

INPUT_RAW_HEAP_DUMP_FILE_PATH = "/home/onyr/code/phdtrack/phdtrack_data_clean/Training/Training/basic/V_7_1_P1/24/17016-1643962152-heap.raw"

class MallocHeaderFlags:
    """
    The flags of the malloc header (m-header).
    """
    def __init__(
            self,
            a: bool,
            m: bool,
            p: bool
        ):
        self.a = a
        self.m = m
        self.p = p

    def __str__(self):
        return f"MallocHeaderFlags(a={self.a}, m={self.m}, p={self.p})"

    def __repr__(self):
        return str(self)

class MallocHeader:
    """
    The malloc header (m-header) which contains size and flags.
    """
    def __init__(
            self,
            block_index: int,
            size: int,
            flags: MallocHeaderFlags
        ):
        self.block_index = block_index
        self.size = size
        self.flags = flags

    def __str__(self):
        return f"MallocHeader(block_index={self.block_index}, size={self.size}, flags={self.flags})"

    def __repr__(self):
        return str(self)

class Chunk:
    """
    A chunk of memory.
    """
    def __init__(
            self,
            block_index: int,
            address: int,
            size: int,
            flags: MallocHeaderFlags,
        ):
        self.user_start_block_index = block_index # index of first block of the user data
        self.size = size # size of the user data in bytes
        self.flags = flags # flags of the malloc header
        self.address = address # address of first block of the user data
        self.mchunkptr = address - 2 * 8 # address of the mchunkptr

        self.is_free = False

    def __str__(self):
        return f"Chunk(block_index={self.user_start_block_index}, size={self.size}, flags={self.flags})"

    def __repr__(self):
        return str(self)

def check_first_block_is_only_zeros(blocks: np.ndarray) -> bool:
    """
    Check that the first block is only composed of zeros.
    """
    first_block = blocks[0]
    if first_block.sum() == 0:
        return True
    return False

def parse_malloc_header(block: np.ndarray) -> MallocHeader:
    """
    Parse the malloc header from a block.
    """
    size_and_flags = int.from_bytes(block, byteorder='little')
    size = size_and_flags & ~0x07  # Clear the last 3 bits to get the size
    flags = MallocHeaderFlags(
        a=bool(size_and_flags & 0x04),
        m=bool(size_and_flags & 0x02),
        p=bool(size_and_flags & 0x01)
    )
    return MallocHeader(len(block), size, flags)

def check_chunk_has_only_zeros(
        blocks: np.ndarray,
        chunk: Chunk,
    ) -> bool:
    """
    Check that a chunk is only composed of zeros.
    WARN: On a free block, there is NO footer.
    """
    for i in range(chunk.user_start_block_index, chunk.user_start_block_index + (chunk.size // 8)):
        if i >= len(blocks):
            print(
                f"WARN: Chunk [{chunk.address}] {chunk} is out of bounds. "
                f"Last block index: {len(blocks) - 1} "
                f"Iteration index: {i} "
                )

        else:
            if blocks[i].sum() != 0:
                return False
        
    return True

def print_chunk(blocks: np.ndarray, chunk: Chunk):
    """
    Print a chunk.
    """
    print(f"Printing Chunk [addr:{int_to_little_endian_hex_string(chunk.address)}] {chunk}")
    for i in range(chunk.user_start_block_index, chunk.user_start_block_index + (chunk.size // 8)):
        if i >= len(blocks):
            print(
                f"WARN: Chunk [{chunk.address}] {chunk} is out of bounds. "
                f"Last block index: {len(blocks) - 1} "
                f"Iteration index: {i} "
                )
        else:
            block = blocks[i].tobytes()
            block_as_int = block_bytes_to_addr(block)
            print(f"Block [{i}]: \t {blocks[i].tobytes()} \t\t {block_as_int}")

def is_free_chunk(
        blocks: np.ndarray,
        chunks: list[Chunk],
        current_chunk_index: int,
        heap_start_addr: int,
        heap_size_in_bytes: int,
    ) -> bool:
    """
    Determine if a chunk is free by looking for forward
    and backward pointers.

    Forward pointer must point to the address of the next chunk.
    Backward pointer must point to the address of the previous chunk.
    """
    chunk = chunks[current_chunk_index]

    # # Forward and backward pointers are the next two 8-byte
    # # fields after the header.
    # forward_pointer_block = blocks[chunk.user_start_block_index].tobytes()
    # if not is_valid_pointer(
    #         forward_pointer_block,
    #         heap_start_addr,
    #         heap_size_in_bytes,
    #     ):
    #     return False

    # backward_pointer_block = blocks[chunk.user_start_block_index + 1].tobytes()
    # if not is_valid_pointer(
    #         backward_pointer_block,
    #         heap_start_addr,
    #         heap_size_in_bytes,
    #     ):
    #     return False

    # WARN: Those pointers pointing to chunks are pointing to the
    # mchunkptr !!!

    # # check the forward pointer points to the next chunk
    # # NOTE: don't check if last chunk
    # if current_chunk_index != len(chunks) - 1:
    #     next_chunk = chunks[current_chunk_index + 1]
    #     forward_pointer_addr = block_bytes_to_addr(forward_pointer_block)
    #     if forward_pointer_addr < next_chunk.mchunkptr or forward_pointer_addr > next_chunk.mchunkptr + next_chunk.size + 2:
    #         return False

    # # check the backward pointer points to the previous chunk
    # previous_chunk = chunks[current_chunk_index - 1]
    # backward_pointer_addr = block_bytes_to_addr(backward_pointer_block)
    # if backward_pointer_addr < previous_chunk.mchunkptr or backward_pointer_addr > previous_chunk.mchunkptr + previous_chunk.size + 2:
    #     return False

    # check if P flag of the next chunk is false
    # this means that this chunk is not in use (free)
    if current_chunk_index != len(chunks) - 1:
        next_chunk = chunks[current_chunk_index + 1]
        if next_chunk.flags.p == True:
            return False # current chunk is not free
    else:
        # last chunk, check if zero chunk
        if not check_chunk_has_only_zeros(blocks, chunk):
            return False
        
    # # check that the blocks after pointer blocks are only composed of zeros (except footer)
    # for i in range(chunk.user_start_block_index + 2, chunk.user_start_block_index + (chunk.size // 8) - 1): # -1 since last block is footer size
    #     if i >= len(blocks):
    #         print(
    #             f"WARN: Chunk [{chunk.address}] {chunk} is out of bounds. "
    #             f"Last block index: {len(blocks) - 1} "
    #             f"Iteration index: {i} "
    #             )
    #     else:
    #         if blocks[i].sum() != 0 or (
    #             i < chunk.user_start_block_index + 4 and 
    #             is_valid_pointer(
    #                 blocks[i].tobytes(),
    #                 heap_start_addr,
    #                 heap_size_in_bytes,
    #             )
    #         ):
    #             return False

    return True

def main():

    # get json annotations
    json_file_path = INPUT_RAW_HEAP_DUMP_FILE_PATH.replace("-heap.raw", ".json")
    json_annotations = get_json_annotations(json_file_path)

    # load the heap dump blocks
    blocks = get_blocks_from_heap_dump(
        INPUT_RAW_HEAP_DUMP_FILE_PATH
    )

    # determine the heap start address and the heap size in bytes
    heap_start_addr = get_heap_start_addr(json_annotations)
    heap_size_in_bytes = get_heap_size_in_bytes(blocks)

    # the heap dump starts with an allocated block
    # the first block is only composed of zeros
    # the second block is the malloc header (m-header)
    # which contains size and flags of the first allocated block
    assert check_first_block_is_only_zeros(blocks), (
        "The first block is not composed of only zeros."
    )

    # Initialize counters
    chunks = []
    nb_chunks = 0
    nb_previous_chunk_in_use = 0
    nb_nmap_chunks = 0
    nb_main_arena_chunks = 0

    # Start parsing from the second block
    i = 1
    while i < len(blocks):
        # Parse the malloc header
        malloc_header = parse_malloc_header(blocks[i])

        # Create a chunk object
        chunk = Chunk(
            i+1,
            convert_block_index_to_address(i+1, heap_start_addr),
            malloc_header.size,
            malloc_header.flags
        )

        # Update statistics
        nb_chunks += 1
        if malloc_header.flags.a:
            nb_main_arena_chunks += 1
        if malloc_header.flags.m:
            nb_nmap_chunks += 1
        if malloc_header.flags.p:
            nb_previous_chunk_in_use += 1

        if nb_chunks < 10 or nb_chunks > 900:
            print(f"Parsed Chunk [{nb_chunks}]: {chunk}")

        # save chunk
        chunks.append(chunk)

        # Move to the next chunk
        i += (malloc_header.size // 8)

    # count the number of free chunks
    nb_free_chunks = 0
    for i in range(1, len(chunks)): # skip first chunk which is in use
        if is_free_chunk(
                blocks,
                chunks,
                i,
                heap_start_addr,
                heap_size_in_bytes,
            ):
            chunk = chunks[i]
            chunk.is_free = True

            if nb_free_chunks < 10:
                print(f"Free Chunk [addr:{int_to_little_endian_hex_string(chunk.address)}]: {chunks[i]}")
            nb_free_chunks += 1
    
    nb_zeros_chunks = 0
    for i in range(0, len(chunks)):
        if check_chunk_has_only_zeros(blocks, chunks[i]):
            chunks[i].is_free = True
            print(f"Chunk [{chunks[i].user_start_block_index}] is only composed of zeros: {chunks[i]}")
            nb_zeros_chunks += 1

    # print content of chunks
    #print("Content of chunks:")
    #print_chunk(blocks, chunks[-1])
    for i in range(0, len(chunks)):
        if chunks[i].user_start_block_index == 80:
            print_chunk(blocks, chunks[i])
    
    # compute percentage of free chunks
    percentage_free_chunks = nb_free_chunks / nb_chunks * 100
    print(f"Percentage of free chunks: {percentage_free_chunks}%")

    # compute percentage of blocks in free chunks
    nb_blocks_in_free_chunks = 0
    for i in range(0, len(chunks)):
        if chunks[i].is_free:
            nb_blocks_in_free_chunks += chunks[i].size // 8
    percentage_blocks_in_free_chunks = nb_blocks_in_free_chunks / len(blocks) * 100
    print(f"Percentage of blocks in free chunks: {percentage_blocks_in_free_chunks}%")

    # print statistics
    print(f"Total number of chunks: {nb_chunks}")
    print(f"Total number of chunks with P=1: {nb_previous_chunk_in_use}")
    print(f"Total number of chunks with M=1: {nb_nmap_chunks}")
    print(f"Total number of chunks with A=1: {nb_main_arena_chunks}")
    print(f"Total number of free chunks: {nb_free_chunks}")
    print(f"Total number of chunks only composed of zeros: {nb_zeros_chunks}")

if __name__ == "__main__":
    main()